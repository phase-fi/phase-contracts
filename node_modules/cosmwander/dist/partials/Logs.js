"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
const jsx_runtime_1 = require("react/jsx-runtime");
const chalk = require("chalk");
const child_process_1 = require("child_process");
const react_1 = require("react");
const ScreenContext_1 = require("../context/ScreenContext");
const fileUtils_1 = require("../utils/fileUtils");
let currentCommandOutput = '';
let outs = {};
function hashCommand(cmd) {
  return `${cmd.command}${cmd.args.join('')}${cmd.cwd}`;
}
function spawnOrGetFunction(cmd) {
  (0, fileUtils_1.saveCommandToHistory)(JSON.stringify(cmd, null, 2));
  const hash = hashCommand(cmd);
  if (outs[hash]) return outs[hash];
  outs[hash] = (0, child_process_1.spawn)(cmd.command, cmd.args, {
    cwd: cmd.cwd,
    env: {
      ...process.env,
      ...cmd.env
    }
  });
  return outs[hash];
}
const Logs = ({
  height,
  top
}) => {
  const {
    command,
    setCommand,
    logAppendContent,
    log
  } = (0, ScreenContext_1.useAppContext)();
  const [output, setOutput] = (0, react_1.useState)('');
  const logBoxRef = (0, react_1.useRef)(null);
  (0, react_1.useEffect)(() => {
    if (command) {
      let out = spawnOrGetFunction(command);
      attachListeners(out);
      return () => removeListeners(out);
    }
  }, [command]);
  (0, react_1.useEffect)(() => {
    setOutput(output + logAppendContent);
    scrollToBottom();
  }, [logAppendContent]);
  function appendHandler(data) {
    setOutput(output + data.toString());
    currentCommandOutput += data.toString();
    scrollToBottom();
  }
  function closeHandler() {
    const savedOutput = (' ' + currentCommandOutput).slice(1);
    setTimeout(() => {
      if (command?.callback) command?.callback(savedOutput);
    }, 100);
    setCommand(undefined);
    currentCommandOutput = '';
    if (command) {
      const hash = hashCommand(command);
      delete outs[hash];
    }
  }
  function attachListeners(out) {
    out.stdout.on('data', appendHandler);
    out.stderr.on('data', appendHandler);
    out.stderr.on('close', closeHandler);
  }
  function removeListeners(out) {
    out.stdout.off('data', appendHandler);
    out.stderr.off('data', appendHandler);
    out.stderr.off('close', closeHandler);
  }
  function scrollToBottom() {
    logBoxRef.current?.setScrollPerc(100);
  }
  (0, react_1.useEffect)(() => {
    if (command) {
      let out = spawnOrGetFunction(command);
      attachListeners(out);
      return () => removeListeners(out);
    }
  }, [output]);
  return (0, jsx_runtime_1.jsx)("box", {
    label: command ? chalk.bgRed(` ${command.command} ${command.args.join(' ')} `) : ' logs ',
    ref: logBoxRef,
    border: {
      type: 'line'
    },
    height: height,
    top: top,
    width: '100%',
    mouse: true,
    scrollable: true,
    style: {
      scrollbar: {
        bg: 'blue',
        fg: 'red',
        track: {
          bg: 'cyan',
          fg: 'magenta'
        }
      }
    },
    children: output
  });
};
exports.default = Logs;